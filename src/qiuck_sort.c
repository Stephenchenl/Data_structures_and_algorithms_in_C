#include "../inc/my_library.h"

/*
快速排序，从小到大

适用情况：
1、大规模数据排序：快速排序在处理大规模数据集时表现出色，因为它的平均时间复杂度为O(n log n)，
    其中n是待排序元素的数量。这使得它成为处理大数据集时的有效选择。

2、内存受限制时：尽管快速排序在最坏情况下的空间复杂度为O(n)（递归调用栈的深度），
    但在平均情况下，它的空间复杂度为O(log n)（递归调用栈的深度与递归树的深度成正比）。
    因此，当内存资源有限时，快速排序通常是一个不错的选择，
    尤其是与其他需要额外空间来存储数据的排序算法（如归并排序）相比。

3、随机数据或无序数据：快速排序在处理随机分布的数据或无序数据时性能良好。
    由于它的划分过程是基于随机选择的基准值，因此不太可能出现最坏情况的时间复杂度。

4、需要原地排序时：快速排序是一种原地排序算法，它直接在输入数组上进行操作而不需要额外的存储空间（除了递归调用栈之外）。
    这使得它适用于需要在有限内存空间内对数组进行排序的情况。

5、外部排序：虽然快速排序通常用于内部排序（即完全在内存中进行的排序），
    但它也可以作为外部排序算法的一部分，用于处理无法一次性加载到内存中的大数据集。
    在这种情况下，可以将数据集分成小块，在内存中使用快速排序进行排序，然后再合并这些已排序的小块。

时间复杂度：O(N*logN)

参数解释:
    int arr[]：待排序的数组
    int low：第一个元素的索引值
    int high：最后一个元素的索引值

基本思想：快速排序的基本思想是采用分治的策略，
    通过选择一个基准值（pivot），将待排序的数组划分为两个子数组，
    使得基准值左边的元素都小于它，右边的元素都大于它。
    然后，对这两个子数组递归地进行快速排序，最终使整个数组有序。

步骤：
    1、选择基准值：随机选择一个数作为基准值。
        1.1、输入数据是随机的
            这种情况下使用数组第一个元素或最后一个元素或是三数取中法都是可以的
        1.2、输入数据是预排序的
            这种情况下不能使用数组第一个元素或者最后一个元素
            可以使用随机数法，然而随机数法需要生成随机数，这是需要花费昂贵的时间的，并不能减少算法的运行时间
            最好使用三数取中法
    2、划分（partition）：重新排列数组，所有比基准值小的元素放在基准值的左边，
        所有比基准值大的元素放在基准值的右边。
        在这个过程中，基准值所处的位置称为划分点，它将数组划分为两个子数组。
    3、递归排序：递归地进行上面一个步骤
    4、合并：由于快速排序实际上是原地排序的算法，是直接在数组上进行操作的，
        所以并没有单独的合并操作，当排序好的适合就已经自然地合并好了

优化：
    1、基准值选取策略：使用三数取中法
    2、在N<=20（N是数据量）的时候，快速排序不如插入排序，
        因此可以将插入排序嵌入到快速排序中，用于处理小数据
    3、三向切分：用于处理重复元素
    4、尾递归优化（待考虑，并不是所有的编译器环境都支持尾递归优化）
*/

void quicksort(int arr[], int low, int high){  
    if (low < high) {  
        int pi = partition(arr, low, high); //获取基准值的索引  
  
        quicksort(arr, low, pi - 1); //对基准值左边的子数组进行快速排序  
        quicksort(arr, pi + 1, high); //对基准值右边的子数组进行快速排序  
    }  
}

int partition(int arr[], int low, int high){
    int pivot = arr[high]; //选择最后一个元素作为基准值  
    int i = (low - 1); //小于基准值的元素的索引  
  
    for (int j = low; j <= high - 1; j++) {  
        if (arr[j] < pivot) {  
            i++;  
            swap_int(&arr[i], &arr[j]);  
        }  
    }  
    swap_int(&arr[i + 1], &arr[high]); //将基准值放到正确的位置上  
    return (i + 1); //返回基准值的索引  
}